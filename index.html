<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Mini Souls-like 3D (Pixel Art) - Single File (Enhanced)</title>
  <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    html,body{height:100%;margin:0;background:#0f0f12;color:#eee;font-family:Inter,system-ui,monospace}
    #ui{position:fixed;left:12px;top:12px;z-index:10;max-width:360px}
    .panel{background:rgba(0,0,0,0.45);padding:10px;border-radius:8px;margin-bottom:8px}
    canvas{display:block}
    .hud{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:rgba(0,0,0,0.5);padding:8px 12px;border-radius:999px}
    .bar{height:8px;background:#333;border-radius:8px;overflow:hidden}
    .bar > .fill{height:100%;background:linear-gradient(90deg,#e74c3c,#e67e22)}
    .bar2 > .fill{height:100%;background:linear-gradient(90deg,#00b894,#00cec9)}
    small{opacity:0.8}
  </style>
</head>
<body>
  <div id="ui">
    <div class="panel">
      <strong>Mini Souls-like (3D, pixel look) — Enhanced</strong>
      <div>Controles: WASD mover • Mouse girar • Click esquerdo atacar • Espaço esquiva/rolar</div>
      <div>Features adicionados: animações interpoladas, hitstun, stamina, sons WebAudio, IA em state-machine, waves e limites de nível</div>
    </div>
    <div class="panel">
      <div>Vida: <span id="hpText">100</span></div>
      <div class="bar" style="width:260px"><div id="hpFill" class="fill" style="width:100%"></div></div>
      <div style="height:8px"></div>
      <div>Stamina: <span id="stText">100</span></div>
      <div class="bar2" style="width:260px"><div id="stFill" class="fill" style="width:100%"></div></div>
    </div>
    <div class="panel">
      <div>Wave: <span id="waveText">0</span> • Enemies: <span id="enemyCount">0</span></div>
      <small>Press 1/2/3/4 para spawn manual. R = reiniciar</small>
    </div>
  </div>
  <div class="hud">Use Shift para correr (consome stamina)</div>

<script>
// Enhanced single-file souls-like prototype
// Added: smooth animations (lerp), hitstun/stagger, stamina system, WebAudio SFX, improved AI state machine, waves, level boundaries, refined camera

let scene, camera, renderer, controls, audioCtx;
let clock = new THREE.Clock();
let player, enemies = [], projectiles = [], effects = [];
let input = { forward:false, back:false, left:false, right:false, attacking:false, dodge:false, run:false };
let attackCooldown = 0, dodgeCooldown = 0, invulnerable = 0;
let score = 0; let wave = 0; let waveState = 'waiting'; let waveTimer = 0;

init(); animate();

function init(){
  scene = new THREE.Scene(); scene.background = new THREE.Color(0x0c0c0e);
  camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 1000); camera.position.set(0,6,10);
  renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth, innerHeight); document.body.appendChild(renderer.domElement);
  controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enabled=false; // we'll control camera manually

  // basic lights
  scene.add(new THREE.AmbientLight(0xffffff,0.5)); const dir=new THREE.DirectionalLight(0xffffff,0.6); dir.position.set(5,10,2); scene.add(dir);

  // ground and boundaries
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(80,80), new THREE.MeshStandardMaterial({color:0x202024})); ground.rotation.x=-Math.PI/2; scene.add(ground);
  const bounds = 20; // level boundary radius

  // helper grid (subtle)
  const grid = new THREE.GridHelper(80,80,0x222222,0x111111); grid.position.y=0.01; scene.add(grid);

  // audio
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // player
  player = createActor({type:'player', color:'#6ab04c', size:0.9, maxHp:100}); player.mesh.position.set(0,0.5,0); player.stamina=100; player.maxStamina=100; player.speed=4; player.isDodging=false; player.isRunning=false;
  player.anim = { tilt:0, bob:0 };
  scene.add(player.mesh);

  // initial enemies
  spawnWave(1);

  // input
  window.addEventListener('keydown', onKeyDown); window.addEventListener('keyup', onKeyUp);
  renderer.domElement.addEventListener('pointerdown', ()=>{ input.attacking = true }); renderer.domElement.addEventListener('pointerup', ()=>{ input.attacking = false });
  window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
}

function createActor(opts){
  const geom = new THREE.BoxGeometry(opts.size, opts.size, opts.size);
  const mat = new THREE.MeshStandardMaterial({map:pixelTexture(opts.color), roughness:0.8});
  const mesh = new THREE.Mesh(geom, mat); mesh.castShadow=true; mesh.receiveShadow=true;
  return { mesh, hp: opts.maxHp||20, maxHp: opts.maxHp||20, type: opts.type, size: opts.size };
}

function spawnEnemy(pos, kind=null, isElite=false){
  const types = ['melee','ranged','fast']; if(!kind) kind = types[Math.floor(Math.random()*types.length)];
  if(Math.random()<0.08) isElite = true;
  const color = isElite? '#f1c40f' : (kind=='melee' ? '#e74c3c' : (kind=='ranged' ? '#3498db' : '#9b59b6'));
  const baseHp = kind=='melee'?50:(kind=='ranged'?35:22); const size = kind=='fast'?0.6:0.9;
  const e = createActor({type:kind,color,size,maxHp:isElite?baseHp*1.6:baseHp});
  e.mesh.position.copy(pos); e.kind=kind; e.isElite=isElite; e.speed = kind=='melee'?1.0:(kind=='ranged'?0.75:1.6);
  e.state = 'idle'; e.stateTimer = 0; e.attackTimer = 0; e.stagger = 0; e.patrolTarget = null;
  // perception/cooldowns
  e.perception = 12; e.attackRange = (kind=='ranged'?8:1.6); enemies.push(e); scene.add(e.mesh);
}

function spawnWave(n){ wave++; waveState='spawning'; waveTimer=0; const count = 3 + n*2; for(let i=0;i<count;i++){ spawnEnemy(randomSpawnPos()); } document.getElementById('waveText').innerText = wave; }

function randomSpawnPos(){ const angle=Math.random()*Math.PI*2; const r=8+Math.random()*12; return new THREE.Vector3(Math.cos(angle)*r,0.5,Math.sin(angle)*r); }

function animate(){ requestAnimationFrame(animate); const dt = Math.min(0.05, clock.getDelta()); updatePlayer(dt); updateEnemies(dt); updateProjectiles(dt); updateEffects(dt); updateWave(dt); updateUI(); updateCamera(dt); renderer.render(scene,camera); }

function updatePlayer(dt){
  // stamina regen/usage
  if(input.run && (input.forward||input.back||input.left||input.right) && player.stamina>6){ player.isRunning=true; player.stamina -= 18*dt; } else { player.isRunning=false; player.stamina = Math.min(player.maxStamina, player.stamina + 12*dt); }
  // movement
  const dir = new THREE.Vector3(); if(input.forward) dir.z -=1; if(input.back) dir.z +=1; if(input.left) dir.x -=1; if(input.right) dir.x +=1;
  if(dir.lengthSq()>0){ dir.normalize(); const yaw = getCameraYaw(); const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)); const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize(); const move = forward.multiplyScalar(-dir.z).add(right.multiplyScalar(dir.x)).normalize(); const spd = player.speed * (player.isRunning?1.6:1.0); player.mesh.position.add(move.multiplyScalar(spd*dt)); // smooth rotate
    const target = player.mesh.position.clone().add(move); player.mesh.quaternion.slerp(new THREE.Quaternion().setFromRotationMatrix(new THREE.Matrix4().lookAt(player.mesh.position, target, new THREE.Vector3(0,1,0))), 0.18);
    player.anim.tilt = lerp(player.anim.tilt, Math.max(-0.18, Math.min(0.18, -move.x*0.6)), 0.12);
  } else { player.anim.tilt = lerp(player.anim.tilt, 0, 0.08); }

  // attack/dodge/stamina checks
  attackCooldown -= dt; dodgeCooldown -= dt; invulnerable = Math.max(0, invulnerable - dt);
  if(input.attacking && attackCooldown<=0 && player.stamina>=10){ performAttack(); attackCooldown=0.5; player.stamina -= 10; }
  if(input.dodge && dodgeCooldown<=0 && player.stamina>=18){ performDodge(); dodgeCooldown=0.9; player.stamina -= 18; }

  if(player.stagger>0) player.stagger = Math.max(0, player.stagger - dt);

  // keep inside bounds
  const maxR = 28; if(player.mesh.position.length() > maxR){ const v = player.mesh.position.clone().setLength(maxR); player.mesh.position.copy(v); }
}

function performAttack(){ playSfx('attack'); // swing arc
  const origin = player.mesh.position.clone(); const forward = new THREE.Vector3(); player.mesh.getWorldDirection(forward); const range=2.2; const arc=Math.PI/2; const dmg=20;
  enemies.forEach(e=>{ const to=e.mesh.position.clone().sub(origin); to.y=0; const d=to.length(); if(d>range) return; const ang = forward.angleTo(to.normalize()); if(ang<=arc/2){ e.hp -= dmg * (e.isElite?1.2:1); e.stagger = 0.4; e.state='stagger'; e.stateTimer = 0.4; spawnHitEffect(e.mesh.position); } });
}

function performDodge(){ playSfx('dodge'); const forward=new THREE.Vector3(); player.mesh.getWorldDirection(forward); const dash=2.4; player.mesh.position.add(forward.multiplyScalar(dash)); invulnerable=0.7; // small visual
  const splash=new THREE.Mesh(new THREE.PlaneGeometry(1.4,1.4), new THREE.MeshBasicMaterial({map:pixelCircleTexture('#ffffff',8),transparent:true,opacity:0.28})); splash.position.copy(player.mesh.position); splash.position.y=0.51; splash.rotation.x=-Math.PI/2; scene.add(splash); setTimeout(()=>scene.remove(splash),240);
}

function updateEnemies(dt){
  for(let i=enemies.length-1;i>=0;i--){ const e = enemies[i]; if(e.hp<=0){ playSfx('death'); scene.remove(e.mesh); enemies.splice(i,1); score+=10; continue; }
    if(e.stagger>0){ // stagger animation
      e.mesh.position.add(new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).multiplyScalar(0.02)); e.stagger = Math.max(0, e.stagger - dt); continue; }
    // perception
    const toPlayer = player.mesh.position.clone().sub(e.mesh.position); toPlayer.y=0; const dist = toPlayer.length();
    // state machine
    switch(e.state){
      case 'idle':
        if(dist < e.perception) e.state = 'chase'; else { if(Math.random()<0.002) { e.patrolTarget = randomSpawnPos(); e.state='patrol'; } }
        break;
      case 'patrol':
        if(!e.patrolTarget) e.state='idle'; else { const dir = e.patrolTarget.clone().sub(e.mesh.position); dir.y=0; if(dir.length()<0.6) e.state='idle'; else e.mesh.position.add(dir.normalize().multiplyScalar(e.speed*dt*0.6)); }
        if(dist < e.perception) e.state='chase';
        break;
      case 'chase':
        // approach or back away if ranged
        if(e.kind=='ranged'){
          if(dist > e.attackRange*0.9) e.mesh.position.add(toPlayer.normalize().multiplyScalar(e.speed*dt)); else if(dist < e.attackRange*0.6) e.mesh.position.add(toPlayer.normalize().multiplyScalar(-e.speed*dt));
        } else { if(dist > 1.6) e.mesh.position.add(toPlayer.normalize().multiplyScalar(e.speed*dt)); }
        e.attackTimer -= dt; if(dist <= e.attackRange + 0.2 && e.attackTimer<=0){ e.state='attack'; }
        if(dist>e.perception*1.6) e.state='idle';
        break;
      case 'attack':
        // perform attack then go to cooldown
        if(e.kind=='ranged'){ rangedShoot(e); } else { enemyMeleeAttack(e); }
        e.attackTimer = 1.0 + (e.isElite?0.6:0); e.state='chase';
        break;
    }
    e.mesh.lookAt(player.mesh.position.clone());
  }
}

function enemyMeleeAttack(e){ const d = e.mesh.position.distanceTo(player.mesh.position); if(d<1.6 && invulnerable<=0){ playSfx('hit'); player.hp -= (e.isElite?18:9); player.stagger = 0.28; spawnHitEffect(player.mesh.position); if(player.hp<=0) onPlayerDeath(); } }

function rangedShoot(e){ playSfx('shoot'); const dir = player.mesh.position.clone().sub(e.mesh.position).normalize(); const proj = { pos: e.mesh.position.clone(), dir, speed:8 + (e.isElite?1:0), dmg: e.isElite?14:8, life:3 }; const g = new THREE.Mesh(new THREE.BoxGeometry(0.22,0.22,0.22), new THREE.MeshBasicMaterial({map:pixelTexture('#ffd166')})); g.position.copy(proj.pos); scene.add(g); proj.mesh=g; projectiles.push(proj); }

function updateProjectiles(dt){ for(let i=projectiles.length-1;i>=0;i--){ const p=projectiles[i]; p.pos.add(p.dir.clone().multiplyScalar(p.speed*dt)); p.mesh.position.copy(p.pos); p.life -= dt; if(p.life<=0){ scene.remove(p.mesh); projectiles.splice(i,1); continue; } if(p.pos.distanceTo(player.mesh.position) < 0.9 && invulnerable<=0){ playSfx('hit'); player.hp -= p.dmg; spawnHitEffect(player.mesh.position); scene.remove(p.mesh); projectiles.splice(i,1); if(player.hp<=0) onPlayerDeath(); } } }

function updateEffects(dt){ for(let i=effects.length-1;i>=0;i--){ const ef=effects[i]; ef.life-=dt; if(ef.life<=0){ scene.remove(ef.mesh); effects.splice(i,1); } else { ef.mesh.material.opacity = Math.max(0, ef.life/ef.max); } } }

function spawnHitEffect(pos){ const p = new THREE.Mesh(new THREE.PlaneGeometry(0.6,0.6), new THREE.MeshBasicMaterial({map:pixelCircleTexture('#fffbf0',6),transparent:true})); p.position.copy(pos); p.position.y=1.0; p.rotation.x=-Math.PI/2; scene.add(p); effects.push({mesh:p,life:0.18,max:0.18}); }

function updateWave(dt){ // simple wave controller
  document.getElementById('enemyCount').innerText = enemies.length;
  if(waveState==='spawning'){ if(enemies.length>0) waveState='inprogress'; else { waveState='waiting'; waveTimer=2.0; } }
  else if(waveState==='inprogress'){ if(enemies.length===0){ waveState='waiting'; waveTimer=2.0; } }
  else if(waveState==='waiting'){ waveTimer -= dt; if(waveTimer<=0){ spawnWave(wave+1); } }
}

function updateUI(){ document.getElementById('hpText').innerText = Math.max(0, Math.round(player.hp)); document.getElementById('hpFill').style.width = `${(player.hp/player.maxHp)*100}%`; document.getElementById('stText').innerText = Math.round(player.stamina); document.getElementById('stFill').style.width = `${(player.stamina/player.maxStamina)*100}%`; }

function updateCamera(dt){ // smoother third-person: offset depends on running/aim
  const offset = new THREE.Vector3(0,4.2,8.8 - (player.isRunning?1.5:0)); const desired = player.mesh.position.clone().add(offset.applyQuaternion(player.mesh.quaternion)); camera.position.lerp(desired, 0.12); camera.lookAt(player.mesh.position.clone().add(new THREE.Vector3(0,1.4,0)).lerp(player.mesh.position,0)); }

function onPlayerDeath(){ playSfx('death'); alert('Você morreu! Score: '+score); location.reload(); }

// helpers
function getCameraYaw(){ const v = camera.position.clone().sub(player.mesh.position); v.y=0; v.normalize(); return Math.atan2(v.x, v.z); }
function lerp(a,b,t){ return a + (b-a)*t; }

// Pixel-texture helpers
function pixelTexture(color){ const size=16; const canvas=document.createElement('canvas'); canvas.width=canvas.height=size; const ctx=canvas.getContext('2d'); ctx.fillStyle=color; ctx.fillRect(0,0,size,size); const tex=new THREE.CanvasTexture(canvas); tex.magFilter=THREE.NearestFilter; tex.minFilter=THREE.NearestFilter; tex.generateMipmaps=false; return tex; }
function pixelCircleTexture(color,size){ const s=size; const c=document.createElement('canvas'); c.width=c.height=s; const ctx=c.getContext('2d'); ctx.fillStyle=color; ctx.beginPath(); ctx.arc(s/2,s/2,s/2-1,0,Math.PI*2); ctx.fill(); const t=new THREE.CanvasTexture(c); t.magFilter=THREE.NearestFilter; t.minFilter=THREE.NearestFilter; t.generateMipmaps=false; return t; }

// Input
function onKeyDown(e){ if(e.repeat) return; switch(e.code){ case 'KeyW': input.forward=true; break; case 'KeyS': input.back=true; break; case 'KeyA': input.left=true; break; case 'KeyD': input.right=true; break; case 'Space': input.dodge=true; break; case 'ShiftLeft': input.run=true; break; case 'KeyR': location.reload(); break; } if(e.key==='1') spawnEnemy(randomSpawnPos(),'melee'); if(e.key==='2') spawnEnemy(randomSpawnPos(),'ranged'); if(e.key==='3') spawnEnemy(randomSpawnPos(),'fast'); if(e.key==='4') spawnEnemy(randomSpawnPos(),null); }
function onKeyUp(e){ switch(e.code){ case 'KeyW': input.forward=false; break; case 'KeyS': input.back=false; break; case 'KeyA': input.left=false; break; case 'KeyD': input.right=false; break; case 'Space': input.dodge=false; break; case 'ShiftLeft': input.run=false; break; } }

// Simple SFX with WebAudio (no files)
function playSfx(name){ try{ const t = audioCtx.currentTime; if(name==='attack'){ const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='square'; o.frequency.setValueAtTime(440,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.08,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18); o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.18); }
  else if(name==='hit'){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sawtooth'; o.frequency.setValueAtTime(180,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.06,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.12); o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.12); }
  else if(name==='dodge'){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(620,t); g.gain.setValueAtTime(0.0001,t); g.gain.linearRampToValueAtTime(0.04,t+0.01); g.gain.linearRampToValueAtTime(0.0001,t+0.18); o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.18); }
  else if(name==='shoot'){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.setValueAtTime(320,t); g.gain.setValueAtTime(0.0001,t); g.gain.linearRampToValueAtTime(0.06,t+0.01); g.gain.linearRampToValueAtTime(0.0001,t+0.22); o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.22); }
  else if(name==='death'){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.setValueAtTime(120,t); g.gain.setValueAtTime(0.0001,t); g.gain.linearRampToValueAtTime(0.12,t+0.02); g.gain.linearRampToValueAtTime(0.0001,t+0.5); o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.5); } }catch(err){}
}

</script>
</body>
</html>
